#textdomain wesnoth-Rise_of_the_Elementalist

#define TIERED_MESSAGE FILTER1 FILTER2 FILTER3 MESSAGE
    [if]
        [have_unit]
            {FILTER1}
        [/have_unit]
        [then]
            [message]
                {FILTER1}
                message={MESSAGE}
            [/message]
        [/then]
        [else]
            [if]
                [have_unit]
                    {FILTER2}
                [/have_unit]
                [then]
                    [message]
                      {FILTER2}
                      message={MESSAGE}
                    [/message]
                [/then]
                [else]
                    [message]
                      {FILTER3}
                      message={MESSAGE}
                    [/message]
                [/else]
            [/if]
        [/else]
    [/if]
#enddef

#define TRANSFORM_HEAL FILTER TYPE
    {TRANSFORM_UNIT {FILTER} {TYPE}}
    {FULL_HEAL {FILTER}}
#enddef

#define ENEMIES_DEFEATED_EVENT_MACRO
    [event]
        name=enemies defeated
        [endlevel]
            result=victory
            {NEW_GOLD_CARRYOVER 40}
        [/endlevel]
    [/event]
#enddef

#define REDRAW_MACRO
    [redraw]
        side=1
    [/redraw]
#enddef

#define FILTER_LOYALS
    [filter_wml]
        upkeep="loyal"
    [/filter_wml]
#enddef

#define RECALL_LOYALS
    [store_unit]
        variable=loyals
        [filter]
            {FILTER_LOYALS}
            [not]
                canrecruit=yes
            [/not]
            x,y=recall,recall
        [/filter]
    [/store_unit]

    {FOREACH loyals loyal_one}
        [recall]
            id=$loyals[$loyal_one].id
            find_vacant=yes
        [/recall]
    {NEXT loyal_one}
    {CLEAR_VARIABLE loyals}
#enddef

#define WEAPON_SPECIAL_ESSENCE_DEVOUR
    [essencedevour]
        id=essencedevour
        name= _ "devour"
        description= _ "Devour:
When a unit is killed by a devouring attack of a magical essence, the energy of the killed unit is converted to wisp. This affects all units, including Undead and units in villages."
    [/essencedevour]
#enddef

#define RAISE_ALL_DEAD_EVENT_MACRO RAISE_SIDE TYPE FIRST_TIME_WML
    [event]
        name=prestart
        {VARIABLE show_raise_dead_message yes}
    [/event]
    [event]
        name=victory
        {CLEAR_VARIABLE show_raise_dead_message}
    [/event]
    [event]
        name=die
        first_time_only=no
        [filter]
            [filter_wml]
                [not]
                    [status]
                        not_living=yes
                    [/status]
                [/not]
            [/filter_wml]
        [/filter]
        [filter_second_attack]
            [not]
                special=plague
            [/not]
        [/filter_second_attack]

        [if]
            [have_unit]
                side={RAISE_SIDE}
                canrecruit=yes
            [/have_unit]
            [then]
                [fire_event]
                    name=before raise unit
                    [primary_unit]
                        id=$unit.id
                    [/primary_unit]
                    [secondary_unit]
                        id=$second_unit.id
                    [/secondary_unit]
                [/fire_event]

                [store_unit]
                    variable=dead_store
                    kill=yes
                    [filter]
                        x=$x1
                        y=$y1
                    [/filter]
                [/store_unit]

                {GENERIC_UNIT {RAISE_SIDE} {TYPE} $x1 $y1}
                [+unit]
                    moves=0
                    attacks_left=0
                    upkeep=loyal
                    variation=$dead_store.undead_variation
                [/unit]

                {CLEAR_VARIABLE dead_store}

                [if]
                    [variable]
                        name=show_raise_dead_message
                        equals=yes
                    [/variable]
                    [then]
                        {VARIABLE show_raise_dead_message no}
                        {FIRST_TIME_WML}
                    [/then]
                [/if]
            [/then]
        [/if]
    [/event]
#enddef

#define MSG FILTER MESSAGE
    [message]
        {FILTER}
        message={MESSAGE}
    [/message]
#enddef

#define NARRATOR MESSAGE
    {MSG (speaker=narrator) {MESSAGE}}
#enddef

#define CONDITIONAL_OBJECTIVE_WML OBJECTIVE_WML TEST_WML
    {OBJECTIVE_WML}
    [+objective]
        [show_if]
            {TEST_WML}
        [/show_if]
    [/objective]
#enddef
#define CONDITIONAL_OBJECTIVE OBJECTIVE_WML VAR_NAME TEST_OP TEST_VALUE
    {CONDITIONAL_OBJECTIVE_WML {OBJECTIVE_WML} (
        [variable]
            name={VAR_NAME}
            {TEST_OP}={TEST_VALUE}
        [/variable]
    )}
#enddef

#define ON_ATTACK_MESSAGE VAR_NAME FILTER_1 FILTER_2 MESSAGES
    [event]
        name=prestart
        {VARIABLE {VAR_NAME} yes}
    [/event]

    [event]
        name=attack
        first_time_only=no
        [filter]
            {FILTER_1}
        [/filter]
        [filter_second]
            {FILTER_2}
        [/filter_second]
        {IF_VAR {VAR_NAME} equals yes (
            [then]
                {VARIABLE unit1_id $unit.id}
                {VARIABLE unit2_id $second_unit.id}
                {MESSAGES}
                {CLEAR_VARIABLE {VAR_NAME}}
                {CLEAR_VARIABLE unit1_id}
                {CLEAR_VARIABLE unit2_id}
            [/then]
        )}
    [/event]
    [event]
        name=attack
        first_time_only=no
        [filter]
            {FILTER_2}
        [/filter]
        [filter_second]
            {FILTER_1}
        [/filter_second]
        {IF_VAR {VAR_NAME} equals yes (
            [then]
                {VARIABLE unit2_id $unit.id}
                {VARIABLE unit1_id $second_unit.id}
                {MESSAGES}
                {CLEAR_VARIABLE {VAR_NAME}}
                {CLEAR_VARIABLE unit1_id}
                {CLEAR_VARIABLE unit2_id}
            [/then]
        )}
    [/event]

    [event]
        name=victory
        {CLEAR_VARIABLE {VAR_NAME}}
    [/event]
#enddef

#define FIND_NEARBY FILTER X Y LIMIT
    # Does a search for a nearby location that matches the given filter.
    # Basically just looks for such a location with increasing radius until it
    # finds at least one. This is sadly inefficient, but implementing BFS in
    # WML is... difficult. Once LIMIT is reached, the entire map is searched.
    # This macro creates the 'nearby_locations' and 'nearby_distance'
    # variables, which can be used to access a list of locations found and the
    # distance to those locations, respectively. They should eventually be
    # cleared, which can be accomplished using the CLEANUP_SEARCH macro.
    [clear_variable]
        name=nearby_locations
    [/clear_variable]
    [set_variable]
        name=nearby_distance
        value=0
    [/set_variable]
    [while]
        [not]
            [variable]
                name=nearby_locations.length
                greater_than=0
            [/variable]
        [/not]
        [and]
            [variable]
                name=nearby_distance
                less_than={LIMIT}
            [/variable]
        [/and]
        [do]
            {DEBUG "Searching depth $nearby_distance around ({X}, {Y})..."}
            [store_locations]
                variable=nearby_locations
                {FILTER}
                [and]
                    x,y={X},{Y}
                    radius=$nearby_distance
                [/and]
            [/store_locations]
            {DEBUG "...found $nearby_locations.length locations."}
            [set_variable]
                name=nearby_distance
                add=1
            [/set_variable]
        [/do]
    [/while]
    [if]
        [variable]
            name=nearby_locations.length
            equals=0
        [/variable]
        [then]
            [store_locations]
                variable=nearby_locations
                {FILTER}
            [/store_locations]
        [/then]
    [/if]
#enddef

#define CLEANUP_SEARCH
    # Clears variables involved in searching (the FIND_NEARBY macro). Put this
    # in your name=victory,defeat tag to clean up if you use FIND_NEARBY within
    # a scenario.
    [clear_variable]
        name=nearby_locations, nearby_distance
    [/clear_variable]
#enddef

#define CONVERT_TERRAIN FROM_FILTER TO_TERRAIN X Y RADIUS MATCHED_WML
    [store_locations]
        [and]
            x,y={X},{Y}
            radius={RADIUS}
        [/and]
        {FROM_FILTER}
        variable=tmp_locs
    [/store_locations]
    {FOREACH tmp_locs i}
        [terrain]
            terrain={TO_TERRAIN}
            x,y=$tmp_locs[$i].x,$tmp_locs[$i].y
        [/terrain]
        {VARIABLE location $tmp_locs[$i]}
        {MATCHED_WML}
        {CLEAR_VARIABLE location}
    {NEXT i}
    {CLEAR_VARIABLE tmp_locs}
#enddef
